b'\xe5\xad\xa6\xe7\x88\xac\xe8\x99\xab\xe5\x88\xa9\xe5\x99\xa8xpath\xef\xbc\x8c\xe7\x9c\x8b\xe8\xbf\x99\xe4\xb8\x80\xe7\xaf\x87\xe5\xb0\xb1\xe5\xa4\x9f\xe4\xba\x86\xef\xbc\x81'XPath，全称 XML Path Language，即 XML 路径语言，它是一门在XML文档中查找信息的语言。XPath 最初设计是用来搜寻XML文档的，但是它同样适用于 HTML 文档的搜索。
所以在做爬虫时，我们完全可以使用 XPath 来做相应的信息抽取，本节我们来介绍一下 XPath 的基本用法。
XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式，另外它还提供了超过 100 个内建函数用于字符串、数值、时间的匹配以及节点、序列的处理等等，几乎所有我们想要定位的节点都可以用XPath来选择。
XPath 于 1999 年 11 月 16 日 成为 W3C 标准，它被设计为供 XSLT、XPointer 以及其他 XML 解析软件使用，更多的文档可以访问其官方网站：https://www.w3.org/TR/xpath/。
我们现用表格列举一下几个常用规则：
表达式描述<br style=""  />nodename选取此节点的所有子节点<br style=""  />/从当前节点选取直接子节点<br style=""  />//从当前节点选取子孙节点<br style=""  />.选取当前节点<br style=""  />..选取当前节点的父节点<br style=""  />@选取属性<br style=""  />
在这里列出了XPath的常用匹配规则，例如 / 代表选取直接子节点，// 代表选择所有子孙节点，. 代表选取当前节点，.. 代表选取当前节点的父节点，@ 则是加了属性的限定，选取匹配属性的特定节点。
例如：
 在后文我们会介绍 XPath 的详细用法，通过 Python 的 LXML 库利用 XPath 进行 HTML 的解析。
在使用之前我们首先要确保安装好了 LXML 库，如没有安装可以参考第一章的安装过程。
我们现用一个实例来感受一下使用 XPath 来对网页进行解析的过程，代码如下：
 在这里我们调用 tostring() 方法即可输出修正后的 HTML 代码，但是结果是 bytes 类型，在这里我们利用 decode() 方法转成 str 类型，结果如下：
 另外我们也可以直接读取文本文件进行解析，示例如下：
     当然此处匹配也可以指定节点名称，如果我们想获取所有 li 节点，示例如下：
 运行结果：
 我们通过 / 或 // 即可查找元素的子节点或子孙节点，加入我们现在想选择 li 节点所有直接 a 子节点，可以这样来实现：
 运行结果：
  但是这里如果我们用 //ul/a 就无法获取任何结果了，因为 / 是获取直接子节点，而在 ul 节点下没有直接的 a 子节点，只有 li 节点，所以无法获取任何匹配结果，代码如下：
  我们知道通过连续的 / 或 // 可以查找子节点或子孙节点，那假如我们知道了子节点怎样来查找父节点呢？在这里我们可以用 .. 来获取父节点。
比如我们现在首先选中 href 是 link4.html 的 a 节点，然后再获取其父节点，然后再获取其 class 属性，代码如下：
  同时我们也可以通过 parent:: 来获取父节点，代码如下：
   我们用 XPath 中的 text() 方法可以获取节点中的文本，我们接下来尝试获取一下上文 li 节点中的文本，代码如下：
  即选中的是这两个节点：
 因此，如果我们想获取 li 节点内部的文本就有两种方式，一种是选取到 a 节点再获取文本，另一种就是使用 //，我们来看下二者的区别是什么。
首先我们选取到 a 节点再获取文本，代码如下：
  在这里我们是逐层选取的，先选取了 li 节点，又利用 / 选取了其直接子节点 a，然后再选取其文本，得到的结果恰好是符合我们预期的两个结果。
我们再来看下用另一种方式 // 选取的结果，代码如下：
  所以说，如果我们要想获取子孙节点内部的所有文本，可以直接用 // 加 text() 的方式获取，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符。如果我们想获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用 text() 方法获取其内部文本，这样可以保证获取的结果是整洁的。
我们知道了用 text() 可以获取节点内部文本，那么节点属性该怎样获取呢？其实还是用 @ 符号就可以，例如我们想获取所有 li 节点下所有 a 节点的 href 属性，代码如下：
 运行结果：
 有时候某些节点的某个属性可能有多个值，例如下面例子：
   运行结果：
 另外我们可能还遇到一种情况，我们可能需要根据多个属性才能确定一个节点，这是就需要同时匹配多个属性才可以，那么这里可以使用运算符 and 来连接，示例如下：
  运算符描述实例返回值<br style=""  />or或price=9.80 or price=9.70如果 price 是 9.80，则返回 true。如果 price 是 9.50，则返回 false。<br style=""  />and与price&gt;9.00 and price&lt;9.90如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。<br style=""  />mod计算除法的余数5 mod 21<br style=""  />\计算两个节点集//book \//cd返回所有拥有 book 和 cd 元素的节点集<br style=""  />+加法6 + 410<br style=""  />-减法6 - 42<br style=""  />*乘法6 * 424<br style=""  />div除法8 div 42<br style=""  />=等于price=9.80如果 price 是 9.80，则返回 true。如果 price 是 9.90，则返回 false。<br style=""  />!=不等于price!=9.80如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。<br style=""  />&lt;小于price&lt;9.80如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。<br style=""  />&lt;=小于或等于price&lt;=9.80如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。<br style=""  />&gt;大于price&gt;9.80如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。<br style=""  />&gt;=大于或等于price&gt;=9.80如果 price 是 9.90，则返回 true。如果 price 是 9.70，则返回 false。<br style=""  />
此表参考来源：http://www.w3school.com.cn/xpath/xpath_operators.asp。
有时候我们在选择的时候可能某些属性同时匹配了多个节点，但是我们只想要其中的某个节点，如第二个节点，或者最后一个节点，这时该怎么办呢？
这时可以利用中括号传入索引的方法获取特定次序的节点，示例如下：
 第二次选择我们选取了最后一个 li 节点，中括号中传入 last() 即可，返回的便是最后一个 li 节点。
第三次选择我们选取了位置小于 3 的 li 节点，也就是位置序号为 1 和 2 的节点，得到的结果就是前 2 个 li 节点。
第四次选择我们选取了倒数第三个 li 节点，中括号中传入 last()-2即可，因为 last() 是最后一个，所以 last()-2 就是倒数第三个。
运行结果如下：
 XPath 提供了很多节点轴选择方法，英文叫做 XPath Axes，包括获取子元素、兄弟元素、父元素、祖先元素等等，在一定情况下使用它可以方便地完成节点的选择，我们用一个实例来感受一下：
  第二次选择我们又加了限定条件，这次在冒号后面加了 div，这样得到的结果就只有 div 这个祖先节点了。
第三次选择我们调用了 attribute 轴，可以获取所有属性值，其后跟的选择器还是 *，这代表获取节点的所有属性，返回值就是 li 节点的所有属性值。
第四次选择我们调用了 child 轴，可以获取所有直接子节点，在这里我们又加了限定条件选取 href 属性为 link1.html 的 a 节点。
第五次选择我们调用了 descendant 轴，可以获取所有子孙节点，这里我们又加了限定条件获取 span 节点，所以返回的就是只包含 span 节点而没有 a 节点。
第六次选择我们调用了 following 轴，可以获取当前节点之后的所有节点，这里我们虽然使用的是 * 匹配，但又加了索引选择，所以只获取了第二个后续节点。
第七次选择我们调用了 following-sibling 轴，可以获取当前节点之后的所有同级节点，这里我们使用的是 * 匹配，所以获取了所有后续同级节点。
