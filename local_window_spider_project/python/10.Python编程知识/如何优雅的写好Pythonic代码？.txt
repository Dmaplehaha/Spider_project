b'\xe5\xa6\x82\xe4\xbd\x95\xe4\xbc\x98\xe9\x9b\x85\xe7\x9a\x84\xe5\x86\x99\xe5\xa5\xbdPythonic\xe4\xbb\xa3\xe7\xa0\x81\xef\xbc\x9f'          这个问题最常见，大家从最开始写Java及C++等语言代码都会遇到这个问题。通常是通过一个临时变量来实现的：
  而Python中可以直接交换两个变量，即：
     列表推导式是Java及C++等语言没有的特性，能够很简洁的实现for循环，可以应用于列表，集合或者字典。
 例如我们要求20以内的整除3的数的平方的列表，可以用如下代码实现：
  而通过列表推导式一行代码即可实现：
  列表推导式也可以用于集合和字典，将[...]变为{...}即可。集合和字典的实现如下所示：
     这是一个老生常谈的问题，当我们需要将数个字符串拼接的时候，习惯性的使用 "+" 作为连接字符串的手段。
 然而，由于像字符串这种不可变对象在内存中生成后无法修改，合并后的字符串会重新开辟出一块内存空间来存储。因此每合并一次就会单独开辟一块内存空间，这样会占用大量的内存空间，严重影响代码的效率。
      Java或者C++等语言的写法是新建一个字符串，从最后开始访问原字符串：
  而Python则将字符串看作list，而列表可以通过切片操作来实现反转：
   在C语言或Java语言中，我们寻找一个字符是否在一个list中，通常会设置一个布尔型变量表示是否找到：
  而Python中的通过for...else...会使得代码很简洁，注意else中的代码块仅仅是在for循环中没有执行break语句的时候执行：
  另外，while以及try关键字都可以和else搭配使用.
   enumerate类接收两个参数，其中一个是可以迭代的对象，另外一个是开始的索引。比如，我们想要打印一个列表的索引及其内容，可以用如下代码实现：
  而通过使用enumerate则极大简化了代码，这里索引设置为从1开始（默认是从0开始）：
    lambda可以返回一个可以调用的函数对象，会使得代码更为简洁。若不使用lambda则需要单独定义一个函数：
  使用lambda后仅仅需要一行代码：
  这里注意，lambda生成的是一个可以像其他函数一样使用的函数对象，即
  等价于 

    在打开文件时，通常是通过捕获异常来进行实现的，并且在finally模块中对文件来进行关闭：
  而通过上下文管理中的with语句可以让代码非常简洁：
    装饰器在Python中应用特别广泛，其特点是可以在具体函数执行之前或者之后做相关的操作，比如：执行前打印执行函数的相关信息，对函数的参数进行校验；执行后记录函数调用的相关流水日志等。使用装饰器最大的好处是<strong style="">使得函数功能单一化，仅仅处理业务逻辑，而不附带其它功能</strong>。<br style=""  />
 在函数调用前打印时间函数名相关的信息，不使用装饰器可以用如下代码实现：
  这样写的问题是业务逻辑中会夹杂参数检查，日志记录等信息，使得代码逻辑不够清晰。所以，这种场景需要使用装饰器：
    生成器与列表最大的区别就是，列表是一次性生成的，需要较大的内存空间；而生成器是需要的时候生成的，基本不占用内存空间。生成器分为生成器表达式和生成器函数。
 先看一下列表：
  改为生成器只需要将[...]变为(...)，即
